<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="SOLID Principles (Object-Oriented Design) SOLID ist ein Akronym für fünf Prinzipien, die dabei helfen, sauberen, wartbaren und erweiterbaren Code zu schreiben. Diese Prinzipien sind besonders nützlich in der objektorientierten Programmierung (OOP).
1. Single Responsibility Principle (SRP) Was? Eine Klasse sollte nur eine Aufgabe haben. Es sollte nur einen Grund geben, die Klasse zu ändern. Warum? Wartbarkeit: Änderungen an einer Aufgabe beeinflussen nicht andere Teile des Systems. Testbarkeit: Klassen mit einer einzigen Verantwortung sind einfacher zu testen. Beispiel: Falsch: class Report: def generate_report(self): print(&#34;Generating report...&#34;) def save_report(self): print(&#34;Saving report...&#34;) Richtig: class ReportGenerator: def generate_report(self): print(&#34;Generating report...&#34;) class ReportSaver: def save_report(self): print(&#34;Saving report...&#34;) 2. Open/Closed Principle (OCP) Was? Klassen sollten offen für Erweiterungen, aber geschlossen für Modifikationen sein. Neue Funktionalität sollte durch Hinzufügen von neuem Code (z. B. neue Klassen) erreicht werden, nicht durch Ändern von bestehendem Code. Warum? Stabilität: Bestehender Code bleibt unverändert und funktioniert weiterhin. Erweiterbarkeit: Neue Anforderungen können leicht umgesetzt werden. Beispiel: Falsch: class AreaCalculator: def calculate_area(self, shape): if shape == &#34;circle&#34;: return 3.14 * radius * radius elif shape == &#34;square&#34;: return side * side Bei jeder neuen Form muss die Methode calculate_area geändert werden. class Shape: def area(self): pass class Circle(Shape): def area(self): return 3.14 * self.radius * self.radius class Square(Shape): def area(self): return self.side * self.side Neue Formen können durch Erben von Shape hinzugefügt werden, ohne AreaCalculator zu ändern. 3. Liskov Substitution Principle (LSP) Was? Kindklassen sollten ohne Probleme anstelle ihrer Elternklassen verwendet werden können. Das Verhalten der Kindklasse sollte das der Elternklasse nicht verletzen. Warum? Polymorphismus: Ermöglicht die Verwendung von Subklassen, ohne das System zu brechen. Vorhersagbarkeit: Das Verhalten bleibt konsistent. Beispiel: Falsch: class Bird: def fly(self): print(&#34;Flying...&#34;) class Ostrich(Bird): # Strauß kann nicht fliegen! def fly(self): raise NotImplementedError(&#34;Ostriches can&#39;t fly!&#34;) Die Klasse Ostrich verletzt das Verhalten der Elternklasse Bird, da sie nicht fliegen kann. class Bird: pass class FlyingBird(Bird): def fly(self): print(&#34;Flying...&#34;) class Ostrich(Bird): pass Hier wird die Hierarchie verbessert: FlyingBird erbt von Bird und implementiert fly, während Ostrich einfach nur ein Bird ist, der nicht fliegen kann. 3. Interface Segregation Principle (ISP) Was? Interfaces sollten klein und spezialisiert sein, nicht groß und allgemein. Klassen sollten nicht gezwungen werden, Methoden zu implementieren, die sie nicht brauchen. Warum? Flexibilität: Klassen implementieren nur das, was sie wirklich benötigen. Wartbarkeit: Änderungen an einem Interface betreffen nur die Klassen, die es tatsächlich verwenden. Beispiel: Falsch: class Printer: def print(self): pass def scan(self): pass def fax(self): pass class SimplePrinter(Printer): def print(self): print(&#34;Printing...&#34;) def scan(self): # Wird nicht benötigt! raise NotImplementedError(&#34;SimplePrinter can&#39;t scan!&#34;) def fax(self): # Wird nicht benötigt! raise NotImplementedError(&#34;SimplePrinter can&#39;t fax!&#34;) SimplePrinter muss unnötige Methoden implementieren. class Printer: def print(self): pass class Scanner: def scan(self): pass class FaxMachine: def fax(self): pass class SimplePrinter(Printer): def print(self): print(&#34;Printing...&#34;) Die Interfaces sind aufgeteilt: SimplePrinter implementiert nur Printer. Dependency Inversion Principle (DIP) Was? Abhängigkeiten sollten auf Abstraktionen basieren, nicht auf konkreten Implementierungen. High-Level-Module sollten nicht von Low-Level-Modulen abhängen, sondern beide sollten von Abstraktionen abhängen. Warum? Flexibilität: Einfacherer Austausch von Komponenten. Testbarkeit: Abhängigkeiten können leicht gemockt werden. Beispiel: Falsch: class LightBulb: def turn_on(self): print(&#34;LightBulb: On&#34;) class Switch: def __init__(self): self.bulb = LightBulb() def operate(self): self.bulb.turn_on() Switch hängt direkt von der konkreten Klasse LightBulb ab. class SwitchableDevice: def turn_on(self): pass class LightBulb(SwitchableDevice): def turn_on(self): print(&#34;LightBulb: On&#34;) class Switch: def __init__(self, device: SwitchableDevice): self.device = device def operate(self): self.device.turn_on() Switch hängt von der Abstraktion SwitchableDevice ab, nicht von LightBulb. " />
<meta name="keywords" content=", untagged" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://urbandavebe.github.io/posts/solid/" />


    <title>
        
            Solid :: some random docs 
        
    </title>





  <link rel="stylesheet" href="/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css" integrity="sha256-JEGDzeGjjgsI&#43;CwReRGBKI&#43;arBzJYYzW9OnncQxXaLo=" crossorigin="anonymous">





    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Solid">
  <meta itemprop="description" content="SOLID Principles (Object-Oriented Design) SOLID ist ein Akronym für fünf Prinzipien, die dabei helfen, sauberen, wartbaren und erweiterbaren Code zu schreiben. Diese Prinzipien sind besonders nützlich in der objektorientierten Programmierung (OOP).
1. Single Responsibility Principle (SRP) Was? Eine Klasse sollte nur eine Aufgabe haben. Es sollte nur einen Grund geben, die Klasse zu ändern. Warum? Wartbarkeit: Änderungen an einer Aufgabe beeinflussen nicht andere Teile des Systems. Testbarkeit: Klassen mit einer einzigen Verantwortung sind einfacher zu testen. Beispiel: Falsch: class Report: def generate_report(self): print(&#34;Generating report...&#34;) def save_report(self): print(&#34;Saving report...&#34;) Richtig: class ReportGenerator: def generate_report(self): print(&#34;Generating report...&#34;) class ReportSaver: def save_report(self): print(&#34;Saving report...&#34;) 2. Open/Closed Principle (OCP) Was? Klassen sollten offen für Erweiterungen, aber geschlossen für Modifikationen sein. Neue Funktionalität sollte durch Hinzufügen von neuem Code (z. B. neue Klassen) erreicht werden, nicht durch Ändern von bestehendem Code. Warum? Stabilität: Bestehender Code bleibt unverändert und funktioniert weiterhin. Erweiterbarkeit: Neue Anforderungen können leicht umgesetzt werden. Beispiel: Falsch: class AreaCalculator: def calculate_area(self, shape): if shape == &#34;circle&#34;: return 3.14 * radius * radius elif shape == &#34;square&#34;: return side * side Bei jeder neuen Form muss die Methode calculate_area geändert werden. class Shape: def area(self): pass class Circle(Shape): def area(self): return 3.14 * self.radius * self.radius class Square(Shape): def area(self): return self.side * self.side Neue Formen können durch Erben von Shape hinzugefügt werden, ohne AreaCalculator zu ändern. 3. Liskov Substitution Principle (LSP) Was? Kindklassen sollten ohne Probleme anstelle ihrer Elternklassen verwendet werden können. Das Verhalten der Kindklasse sollte das der Elternklasse nicht verletzen. Warum? Polymorphismus: Ermöglicht die Verwendung von Subklassen, ohne das System zu brechen. Vorhersagbarkeit: Das Verhalten bleibt konsistent. Beispiel: Falsch: class Bird: def fly(self): print(&#34;Flying...&#34;) class Ostrich(Bird): # Strauß kann nicht fliegen! def fly(self): raise NotImplementedError(&#34;Ostriches can&#39;t fly!&#34;) Die Klasse Ostrich verletzt das Verhalten der Elternklasse Bird, da sie nicht fliegen kann. class Bird: pass class FlyingBird(Bird): def fly(self): print(&#34;Flying...&#34;) class Ostrich(Bird): pass Hier wird die Hierarchie verbessert: FlyingBird erbt von Bird und implementiert fly, während Ostrich einfach nur ein Bird ist, der nicht fliegen kann. 3. Interface Segregation Principle (ISP) Was? Interfaces sollten klein und spezialisiert sein, nicht groß und allgemein. Klassen sollten nicht gezwungen werden, Methoden zu implementieren, die sie nicht brauchen. Warum? Flexibilität: Klassen implementieren nur das, was sie wirklich benötigen. Wartbarkeit: Änderungen an einem Interface betreffen nur die Klassen, die es tatsächlich verwenden. Beispiel: Falsch: class Printer: def print(self): pass def scan(self): pass def fax(self): pass class SimplePrinter(Printer): def print(self): print(&#34;Printing...&#34;) def scan(self): # Wird nicht benötigt! raise NotImplementedError(&#34;SimplePrinter can&#39;t scan!&#34;) def fax(self): # Wird nicht benötigt! raise NotImplementedError(&#34;SimplePrinter can&#39;t fax!&#34;) SimplePrinter muss unnötige Methoden implementieren. class Printer: def print(self): pass class Scanner: def scan(self): pass class FaxMachine: def fax(self): pass class SimplePrinter(Printer): def print(self): print(&#34;Printing...&#34;) Die Interfaces sind aufgeteilt: SimplePrinter implementiert nur Printer. Dependency Inversion Principle (DIP) Was? Abhängigkeiten sollten auf Abstraktionen basieren, nicht auf konkreten Implementierungen. High-Level-Module sollten nicht von Low-Level-Modulen abhängen, sondern beide sollten von Abstraktionen abhängen. Warum? Flexibilität: Einfacherer Austausch von Komponenten. Testbarkeit: Abhängigkeiten können leicht gemockt werden. Beispiel: Falsch: class LightBulb: def turn_on(self): print(&#34;LightBulb: On&#34;) class Switch: def __init__(self): self.bulb = LightBulb() def operate(self): self.bulb.turn_on() Switch hängt direkt von der konkreten Klasse LightBulb ab. class SwitchableDevice: def turn_on(self): pass class LightBulb(SwitchableDevice): def turn_on(self): print(&#34;LightBulb: On&#34;) class Switch: def __init__(self, device: SwitchableDevice): self.device = device def operate(self): self.device.turn_on() Switch hängt von der Abstraktion SwitchableDevice ab, nicht von LightBulb.">
  <meta itemprop="datePublished" content="2025-02-08T12:35:44+01:00">
  <meta itemprop="dateModified" content="2025-02-08T12:35:44+01:00">
  <meta itemprop="wordCount" content="554">
  <meta itemprop="keywords" content="Untagged">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Solid">
  <meta name="twitter:description" content="SOLID Principles (Object-Oriented Design) SOLID ist ein Akronym für fünf Prinzipien, die dabei helfen, sauberen, wartbaren und erweiterbaren Code zu schreiben. Diese Prinzipien sind besonders nützlich in der objektorientierten Programmierung (OOP).
1. Single Responsibility Principle (SRP) Was? Eine Klasse sollte nur eine Aufgabe haben. Es sollte nur einen Grund geben, die Klasse zu ändern. Warum? Wartbarkeit: Änderungen an einer Aufgabe beeinflussen nicht andere Teile des Systems. Testbarkeit: Klassen mit einer einzigen Verantwortung sind einfacher zu testen. Beispiel: Falsch: class Report: def generate_report(self): print(&#34;Generating report...&#34;) def save_report(self): print(&#34;Saving report...&#34;) Richtig: class ReportGenerator: def generate_report(self): print(&#34;Generating report...&#34;) class ReportSaver: def save_report(self): print(&#34;Saving report...&#34;) 2. Open/Closed Principle (OCP) Was? Klassen sollten offen für Erweiterungen, aber geschlossen für Modifikationen sein. Neue Funktionalität sollte durch Hinzufügen von neuem Code (z. B. neue Klassen) erreicht werden, nicht durch Ändern von bestehendem Code. Warum? Stabilität: Bestehender Code bleibt unverändert und funktioniert weiterhin. Erweiterbarkeit: Neue Anforderungen können leicht umgesetzt werden. Beispiel: Falsch: class AreaCalculator: def calculate_area(self, shape): if shape == &#34;circle&#34;: return 3.14 * radius * radius elif shape == &#34;square&#34;: return side * side Bei jeder neuen Form muss die Methode calculate_area geändert werden. class Shape: def area(self): pass class Circle(Shape): def area(self): return 3.14 * self.radius * self.radius class Square(Shape): def area(self): return self.side * self.side Neue Formen können durch Erben von Shape hinzugefügt werden, ohne AreaCalculator zu ändern. 3. Liskov Substitution Principle (LSP) Was? Kindklassen sollten ohne Probleme anstelle ihrer Elternklassen verwendet werden können. Das Verhalten der Kindklasse sollte das der Elternklasse nicht verletzen. Warum? Polymorphismus: Ermöglicht die Verwendung von Subklassen, ohne das System zu brechen. Vorhersagbarkeit: Das Verhalten bleibt konsistent. Beispiel: Falsch: class Bird: def fly(self): print(&#34;Flying...&#34;) class Ostrich(Bird): # Strauß kann nicht fliegen! def fly(self): raise NotImplementedError(&#34;Ostriches can&#39;t fly!&#34;) Die Klasse Ostrich verletzt das Verhalten der Elternklasse Bird, da sie nicht fliegen kann. class Bird: pass class FlyingBird(Bird): def fly(self): print(&#34;Flying...&#34;) class Ostrich(Bird): pass Hier wird die Hierarchie verbessert: FlyingBird erbt von Bird und implementiert fly, während Ostrich einfach nur ein Bird ist, der nicht fliegen kann. 3. Interface Segregation Principle (ISP) Was? Interfaces sollten klein und spezialisiert sein, nicht groß und allgemein. Klassen sollten nicht gezwungen werden, Methoden zu implementieren, die sie nicht brauchen. Warum? Flexibilität: Klassen implementieren nur das, was sie wirklich benötigen. Wartbarkeit: Änderungen an einem Interface betreffen nur die Klassen, die es tatsächlich verwenden. Beispiel: Falsch: class Printer: def print(self): pass def scan(self): pass def fax(self): pass class SimplePrinter(Printer): def print(self): print(&#34;Printing...&#34;) def scan(self): # Wird nicht benötigt! raise NotImplementedError(&#34;SimplePrinter can&#39;t scan!&#34;) def fax(self): # Wird nicht benötigt! raise NotImplementedError(&#34;SimplePrinter can&#39;t fax!&#34;) SimplePrinter muss unnötige Methoden implementieren. class Printer: def print(self): pass class Scanner: def scan(self): pass class FaxMachine: def fax(self): pass class SimplePrinter(Printer): def print(self): print(&#34;Printing...&#34;) Die Interfaces sind aufgeteilt: SimplePrinter implementiert nur Printer. Dependency Inversion Principle (DIP) Was? Abhängigkeiten sollten auf Abstraktionen basieren, nicht auf konkreten Implementierungen. High-Level-Module sollten nicht von Low-Level-Modulen abhängen, sondern beide sollten von Abstraktionen abhängen. Warum? Flexibilität: Einfacherer Austausch von Komponenten. Testbarkeit: Abhängigkeiten können leicht gemockt werden. Beispiel: Falsch: class LightBulb: def turn_on(self): print(&#34;LightBulb: On&#34;) class Switch: def __init__(self): self.bulb = LightBulb() def operate(self): self.bulb.turn_on() Switch hängt direkt von der konkreten Klasse LightBulb ab. class SwitchableDevice: def turn_on(self): pass class LightBulb(SwitchableDevice): def turn_on(self): print(&#34;LightBulb: On&#34;) class Switch: def __init__(self, device: SwitchableDevice): self.device = device def operate(self): self.device.turn_on() Switch hängt von der Abstraktion SwitchableDevice ab, nicht von LightBulb.">







    <meta property="article:published_time" content="2025-02-08 12:35:44 &#43;0100 CET" />












    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                hello</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/lernen/">Lernkarten</a></li><li><a href="/about/">About</a></li><li><a href="/">Home</a></li><li><a href="/posts/">Posts</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        3 minutes

        
      </p>
      <p>Author: Unbekannt</p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://urbandavebe.github.io/posts/solid/">Solid</a>
      </h1>

      

      

      

      <div class="post-content">
        <h1 id="solid-principles-object-oriented-design">SOLID Principles (Object-Oriented Design)</h1>
<p>SOLID ist ein Akronym für fünf Prinzipien, die dabei helfen, sauberen, wartbaren und erweiterbaren Code zu schreiben. Diese Prinzipien sind besonders nützlich in der objektorientierten Programmierung (OOP).</p>
<hr>
<h2 id="1-single-responsibility-principle-srp">1. Single Responsibility Principle (SRP)</h2>
<h3 id="was"><strong>Was?</strong></h3>
<ul>
<li>Eine Klasse sollte <strong>nur eine Aufgabe</strong> haben.</li>
<li>Es sollte <strong>nur einen Grund geben</strong>, die Klasse zu ändern.</li>
</ul>
<h3 id="warum"><strong>Warum?</strong></h3>
<ul>
<li><strong>Wartbarkeit</strong>: Änderungen an einer Aufgabe beeinflussen nicht andere Teile des Systems.</li>
<li><strong>Testbarkeit</strong>: Klassen mit einer einzigen Verantwortung sind einfacher zu testen.</li>
</ul>
<h3 id="beispiel"><strong>Beispiel:</strong></h3>
<h4 id="falsch">Falsch:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Report</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_report</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Generating report...&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_report</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Saving report...&#34;</span>)
</span></span></code></pre></div><h4 id="richtig">Richtig:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReportGenerator</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_report</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Generating report...&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReportSaver</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_report</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Saving report...&#34;</span>)
</span></span></code></pre></div><h2 id="2-openclosed-principle-ocp">2. Open/Closed Principle (OCP)</h2>
<h3 id="was-1">Was?</h3>
<ul>
<li>Klassen sollten <strong>offen für Erweiterungen</strong>, aber <strong>geschlossen für Modifikationen</strong> sein.</li>
<li>Neue Funktionalität sollte durch <strong>Hinzufügen von neuem Code</strong> (z. B. neue Klassen) erreicht werden, nicht durch Ändern von bestehendem Code.</li>
</ul>
<h3 id="warum-1">Warum?</h3>
<ul>
<li><strong>Stabilität:</strong> Bestehender Code bleibt unverändert und funktioniert weiterhin.</li>
<li><strong>Erweiterbarkeit:</strong> Neue Anforderungen können leicht umgesetzt werden.</li>
</ul>
<h3 id="beispiel-1"><strong>Beispiel:</strong></h3>
<h4 id="falsch-1">Falsch:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AreaCalculator</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calculate_area</span>(self, shape):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> shape <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;circle&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3.14</span> <span style="color:#f92672">*</span> radius <span style="color:#f92672">*</span> radius
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> shape <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;square&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> side <span style="color:#f92672">*</span> side
</span></span></code></pre></div><ul>
<li>Bei jeder neuen Form muss die Methode calculate_area geändert werden.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shape</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">area</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span>(Shape):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">area</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3.14</span> <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>radius <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>radius
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span>(Shape):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">area</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>side <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>side
</span></span></code></pre></div><ul>
<li>Neue Formen können durch Erben von Shape hinzugefügt werden, ohne AreaCalculator zu ändern.</li>
</ul>
<h2 id="3-liskov-substitution-principle-lsp">3. Liskov Substitution Principle (LSP)</h2>
<h3 id="was-2">Was?</h3>
<ul>
<li><strong>Kindklassen</strong> sollten <strong>ohne Probleme</strong> anstelle ihrer <strong>Elternklassen</strong> verwendet werden können.
Das Verhalten der Kindklasse sollte das der Elternklasse <strong>nicht verletzen.</strong></li>
</ul>
<h3 id="warum-2">Warum?</h3>
<ul>
<li><strong>Polymorphismus:</strong> Ermöglicht die Verwendung von Subklassen, ohne das System zu brechen.</li>
<li><strong>Vorhersagbarkeit:</strong> Das Verhalten bleibt konsistent.</li>
</ul>
<h3 id="beispiel-2"><strong>Beispiel:</strong></h3>
<h4 id="falsch-2">Falsch:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bird</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fly</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Flying...&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Ostrich</span>(Bird):  <span style="color:#75715e"># Strauß kann nicht fliegen!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fly</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">NotImplementedError</span>(<span style="color:#e6db74">&#34;Ostriches can&#39;t fly!&#34;</span>)
</span></span></code></pre></div><ul>
<li>Die Klasse <strong>Ostrich</strong> verletzt das Verhalten der Elternklasse <strong>Bird</strong>, da sie nicht fliegen kann.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bird</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FlyingBird</span>(Bird):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fly</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Flying...&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Ostrich</span>(Bird):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><ul>
<li>Hier wird die Hierarchie verbessert: FlyingBird erbt von Bird und implementiert fly, während Ostrich einfach nur ein Bird ist, der nicht fliegen kann.</li>
</ul>
<h2 id="3-interface-segregation-principle-isp">3. Interface Segregation Principle (ISP)</h2>
<h3 id="was-3">Was?</h3>
<ul>
<li><strong>Interfaces</strong> sollten <strong>klein und spezialisiert</strong> sein, nicht groß und allgemein.</li>
<li>Klassen sollten nicht gezwungen werden, Methoden zu implementieren, die sie nicht brauchen.</li>
</ul>
<h3 id="warum-3">Warum?</h3>
<ul>
<li><strong>Flexibilität:</strong> Klassen implementieren nur das, was sie wirklich benötigen.</li>
<li><strong>Wartbarkeit:</strong> Änderungen an einem Interface betreffen nur die Klassen, die es tatsächlich verwenden.</li>
</ul>
<h3 id="beispiel-3"><strong>Beispiel:</strong></h3>
<h4 id="falsch-3">Falsch:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Printer</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">scan</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fax</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SimplePrinter</span>(Printer):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Printing...&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">scan</span>(self):  <span style="color:#75715e"># Wird nicht benötigt!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">NotImplementedError</span>(<span style="color:#e6db74">&#34;SimplePrinter can&#39;t scan!&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fax</span>(self):  <span style="color:#75715e"># Wird nicht benötigt!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">NotImplementedError</span>(<span style="color:#e6db74">&#34;SimplePrinter can&#39;t fax!&#34;</span>)
</span></span></code></pre></div><ul>
<li>SimplePrinter muss unnötige Methoden implementieren.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Printer</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Scanner</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">scan</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FaxMachine</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fax</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SimplePrinter</span>(Printer):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Printing...&#34;</span>)
</span></span></code></pre></div><ul>
<li>Die Interfaces sind aufgeteilt: SimplePrinter implementiert nur Printer.</li>
</ul>
<h2 id="dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)</h2>
<h3 id="was-4">Was?</h3>
<ul>
<li><strong>Abhängigkeiten</strong> sollten auf <strong>Abstraktionen</strong> basieren, nicht auf konkreten Implementierungen.</li>
<li>High-Level-Module sollten nicht von Low-Level-Modulen abhängen, sondern beide sollten von Abstraktionen abhängen.</li>
</ul>
<h3 id="warum-4">Warum?</h3>
<ul>
<li><strong>Flexibilität:</strong> Einfacherer Austausch von Komponenten.</li>
<li><strong>Testbarkeit:</strong> Abhängigkeiten können leicht gemockt werden.</li>
</ul>
<h3 id="beispiel-4"><strong>Beispiel:</strong></h3>
<h4 id="falsch-4">Falsch:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LightBulb</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">turn_on</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;LightBulb: On&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Switch</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>bulb <span style="color:#f92672">=</span> LightBulb()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">operate</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>bulb<span style="color:#f92672">.</span>turn_on()
</span></span></code></pre></div><ul>
<li>Switch hängt direkt von der konkreten Klasse LightBulb ab.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SwitchableDevice</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">turn_on</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LightBulb</span>(SwitchableDevice):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">turn_on</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;LightBulb: On&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Switch</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, device: SwitchableDevice):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>device <span style="color:#f92672">=</span> device
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">operate</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>device<span style="color:#f92672">.</span>turn_on()
</span></span></code></pre></div><ul>
<li>Switch hängt von der Abstraktion SwitchableDevice ab, nicht von LightBulb.</li>
</ul>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://urbandavebe.github.io/tags/untagged/">untagged</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        554 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2025-02-08 12:35
        

         
          
        
      </p>
    </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://urbandavebe.github.io/posts/migrate-from-jekyll/">
                    <span class="button__icon">←</span>
                    <span class="button__text">Migrate to Hugo from Jekyll</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://urbandavebe.github.io/posts/arch_compendium/">
                    <span class="button__text">Arch_compendium</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; UrbanDaveBE</span>
            <span><a href="https://urbandavebe.github.io/"></a></span>
            <span></span>
            <span><a href="https://urbandavebe.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
            <span>Footer top text here</span>
        </div>
    </div>
    

      
      <div class="footer__inner">
        <div class="social-media-links">
    <a href="https://facebook.com/yourprofile" target="_blank">Facebook</a>
    <a href="https://twitter.com/yourprofile" target="_blank">Twitter</a>
    <a href="https://linkedin.com/in/yourprofile" target="_blank">LinkedIn</a>
  </div>
  
    </div>
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>Footer bottom text</span>
        </div>
    </div>
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js" integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc&#43;cxaJzDdCYbAW0X1G&#43;DgZYvtKFXe6MBex8jUJ2JT25mQx&#43;YjACIng=="></script>




    </body>
</html>
